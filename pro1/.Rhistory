a <- 10
b <- 20
print(a+b)
kbs <- 9 # 객체변수에 double type의 객체의 주소를 참조하도록 함 파이썬 처럼
# kbs = 9 # 함수 안에서 사용 권장
# 9 -> kbs
object.size(kbs)
typeof(kbs) # 자료형
mode(kbs)   # 자료 유형
class(kbs)  # 자료 구조
mbc <- as.integer(kbs) # double 을 integer
typeof(mbc)
is(mbc)
mbc <- 5L # integer 로 저장
typeof(mbc)
ss <- '홍길동'
is(ss)
ss[0]
ss[1]
print(ss) # 함수 내에서 출력하고자 할 때
# print(ss, kbs) 프린트는 한개밖에 출력을 못해서 cat을 써야한다
cat(ss)
cat(ss, kbs)
b <- TRUE
b <- T
is(b)
# 복소수
z <- 5.3-3i
z
Re(z)
Im(z)
is(z)
is(mbc)
plot(kbs)
plot(mbc)
sum(2, 3)
sum(2, 3, NULL) # NULL은 무시하고 연산
sum(2, 3, NA)
rm(b)
b
dim(available.packages())
library(plyr)
#12시 36분 부터 수업
install.packages("plyr") # 패키지 설치하는법
library(plyr)
library(plyr)
ls("package:plyr")
# dataset
data()
iris
head(iris)
tail(iris, 3)
Nile # data
?mean
?mean
hist(iris$Sepal.Length)
# <연습문제1> name, age, address 라는 변수에 적당한 데이터를 대입하시오.
#
# 조건1) 변수의 특성에 맞게 값을 초기화하고 결과를 확인한다.
#
#
# 조건2) 각 변수에 데이터 타입 보기 함수와 타입확인 함수 적용
name <- '신기해'
age <- 33
address <- '강남구'
name
age
# <연습문제2> R에서 제공하는 women dataset을 이용하여 아래의 조건을 처리하시오.
#
# <조건1> women dataset은 어떤 데이터의 모음인가?
head(women, 3)
? women
# <조건2> women dataset의 자료 유형과 자료구조는?
mode(women)
class(women)
v2 <- c(1, 2.5, 3, T, F)
v2
age <- c(23, 26, 32)
age
length(age)
rm(age)
age
v1[c(2:5)]
v1 <- c(13, -5, 15:20, 12, -2:3)
v1
# 인덱싱 / 슬라이싱
v1[1]
v1[-1] # 여집합 1번째만 뺀 나머지 나옴
v1[c(2,5)]
v1[c(2:5)]
v1[-c(2:5)]
v2 <-- v1 + 10
v2
v2 <- v1 %% 3
v2 <-- v1 + 10
v2
v2 <- v1 %% 3
a <- 1:5
a + 5
a - 5
a * 5
a / 5
sqrt(a)
sqrt(a)^2
a
b <- c(6:10) # == 6:10
b
a+b
a*b
a[6] <- 3
a
# Matrix : 2차원 배열(행렬)
a <- 1:8
dim(a) <- c(2, 4)
a
typeof(a)
class(a)
mode(a)
m <- matrix(1:5)
m
dim(m) #차원확인 함수
m <- matrix(c(1:9), nrow=3)
m
dim(m)
a <- matrix(c(1:9), nrow=3, ncol=3)
a
m[c(1,3),c(2:4)]
a
t(a) # 행렬전환 (transpose : 전치)
solve(a)
solve(solve(a))
d <- c(1:12)
arr1 <- array(d)
arr1
class(arr1)
number <- list(name='hong', age=22)
number
# 생성방법1 : vector를 이용 data.frame
np <- c(1,2,3)
name <- c('hong','lee','kim')
pay <- c(330, 450, 500)
df <- data.frame(no, name, pay)
# 생성방법1 : vector를 이용 data.frame
np <- c(1,2,3)
name <- c('hong','lee','kim')
pay <- c(330, 450, 500)
df <- data.frame(no, name, pay)
# 생성방법1 : vector를 이용 data.frame
no <- c(1,2,3)
name <- c('hong','lee','kim')
pay <- c(330, 450, 500)
df <- data.frame(no, name, pay)
df
df
class(df)
mode(df)
is(df)
pay <- c(330, 450, 500)
df <- data.frame(bunho=no, irum=name, imkum=pay)
df
class(df)
mode(df)
is(df)
df$irum
df <- data.frame(irum=c('james','oscar','tom'),
nai=c(22, 25, 27),
row.names = c('one','two','three'))
df
nrow(df)
ncol(df)
str(df)
summary(df) #요약 통계 4분의 수 까지 나옴
head(df, n=2)
tail(df, n=2)
rownames(df)
colnames(df)
# 생성방법2 : matrix를 이용 data.frame
m <- base::matrix(c(1,'hong',150,2,'lee',250,3,'kim',350), 3, by=T)
m
mdf <- data.frame(m)
mdf
colnames(mdf) <- c("c1", "c2")
mdf
mdf
mdf$c1
mdf['c1']
mdf[1]
mdf[-1] #여집합
mdf[1, 2]
mdf[, 2]
mdf[1, ]
mdf[1:2, 1:2]
mdf[2:3, c(1,2)]
# 조건 지정해 행 출력
mdf[mdf$c1 == 2,]
subset(mdf, c1 == 2)
?subset
mdf$c2 <- ifelse(mdf$c2 == 4, NA, mdf$c2)
mdf
csvdf <- read.csv('testdata/emp.csv')
csvdf
# DataFrame을 스크립트 파일로 저장(rdata)
df <- data.frame(eng=c(90, 80, 70), mat=c(55, 67, 90), class=c(1,2,3))
df
write.csv(df)
?write.csv
# DataFrame을 스크립트 파일로 저장(rdata)
df <- data.frame(eng=c(90, 80, 70), mat=c(55, 67, 90), class=c(1,2,3))
df
write.csv(df, file = 'output/mydf.csv')
save(df, file='output/mydf.rda')
rm(df)
df
load('output/mydf.rda')
df
# 객체 file i/o
x <- 1:5
y = 6:10
save(x, y, file='output/mydf.RData')
# 객체 file i/o
x <- 1:5
y = 6:10
save(x, y, file='output/mydf.RData')
rm(list=ls()) #모두 지우기
load('output/mydf.RData')
# 연산자
no <- 7
no >= 2 + 2 * 2 | no < 5 %% 2
# 제어문 : 조건 판단문 - if, switch, which
# 1) if() 함수
x <- 10; y <- 5
if(x + y >= 10){
cat('결과는', x+y)
cat('\n참일 때 수행')
}else{
print('거짓일 때 수행')
a = 10 # 함수 안에서는 <-보다 =으로
}
# mpg dataset을 사용
install.packages('ggplot2')
library(ggplot2)
head(mpg, 3)
head(iris, 3)
mpg <- as.data.frame(ggplot2::mpg) # ggplot2:: 안써도 됨?
head(mpg, 3)
dim(mpg)
str(mpg)
summary(mpg)
if(mean(mpg$total) >= 20){
print('우수연비')
}else{
print('일반연비')
}
if(mean(mpg$total) >= 20){
print('우수연비')
}else{
print('일반연비')
}
# 새로운 칼럼(변수)를 추가 : 통합연비
mpg$total <- (mpg$cty + mpg$hwy) /2
head(mpg, 3)
if(mean(mpg$total) >= 20){
print('우수연비')
}else{
print('일반연비')
}
summary(mpg$total)
hist(mpg$total)
mpg$test <- ifelse(mpg$total >= 20, 'pass', 'fail') #칼럼 새로 만듬
head(mpg)
head(mpg, 3)
tail(mpg, 3)
table(mpg$test)
qplot(mpg$grade)
mpg$grade <- ifelse(mpg$total >= 30,'A', ifelse(mpg$total >= 20, 'B', "C"))
head(mpg, 3)
qplot(mpg$grade)
# switch
switch("age", id="hong", age=23)
# which
name <- c("kor",'eng','mat','kor')
which(name=='eng')
which(df$번호==12)
no <- 10:13
df <- data.frame(번호=no, 이름=name)
df
which(df$번호==12)
set.seed(123)
rnorm(10, mean = 0, sd = 1) # 정규분포를 따르는 난수
hist(rnorn(5000, mean = 0, sd = 1))
runif(10, min=0, max=100)
hist(runif(10, min=0, max=100))
vec <- 1:10
min(vec)
var(vec)
sqrt(var(vec))
sd(vec)
sd(vec) / mean(vec)
quantile(vec)
sum(vec)
prod(vec)
# 사용자 정의 함수
func1 <- function(arg){
print(arg)
return(arg + 10)
}
typeof(func1)
func1(5)
func1(5)
install.packages('httr')
library(httr)
source <- htmlParse(rawToChar(GET(url)$content))
install.packages('XML')
library(XML)
url <- "https://www.melon.com/song/popup/lyricPrint.htm?songId=23452"
source <- htmlParse(rawToChar(GET(url)$content))
source
text <- xpathSApply(source, "//div[@class<div class='box_lyric_text']", xmlValue) #스크래핑
text
text <- xpathSApply(source, "//div[@class='box_lyric_text']", xmlValue) #스크래핑
text
# --------------------------------
# xml data 읽기
url <- "https://raw.githubusercontent.com/pykwon/python/master/seoullibtime5.xml"
doc <- xmlTreeParse(url, useInternalNodes = T, trim = T)
# --------------------------------
# xml data 읽기
url <- "https://raw.githubusercontent.com/pykwon/python/master/seoullibtime5.xml"
r <- GET(url)
doc <- xmlTreeParse(r, useInternalNodes = T, trim = T)
doc
rootNode <- xmlRoot(doc)
rootNode
rootNode[[1]]
rootNode[[1]][[1]]
# ----------------------------------
# json data 읽기
install.packages("rjson")
library(rjson)
stu <- read.csv("testdata/")
stu <- read.csv("testdata/ex_studentlist.csv", fileEncoding = "utf-8")
# 막대
barplot(stu$grade)
barplot(stu$grade, ylim = (0, 5))
stu <- read.csv("testdata/ex_studentlist.csv", fileEncoding = "utf-8")
head(stu, 3)
str(stu)
names(stu)
# 막대
barplot(stu$grade)
barplot(stu$grade, ylim = (0, 5), col = rainbow(3), main = '세로막대')
barplot(stu$grade, ylim = (0, 5), col = rainbow(3), main = '가로막대', horiz = T)
barplot(stu$grade, ylim = c(0, 5), col = rainbow(3), main = '세로막대')
barplot(stu$grade, ylim = c(0, 5), col = rainbow(3),
xlab = '학년',ylab = '학생', main = '가로막대', horiz = T)
barplot(stu$grade, col = c(1,2,3,4,5))
# 점 차트
dotchart(stu$grade)
dotchart(stu$grade, color = 2:5, lcolor = 'black', pch = 1:3, cex = 2)
dotchart(stu$grade, color = 2:5, lcolor = 'black', pch = 1:3, cex = 1.5)
# 원 그래프
df <- stu
source("C:/work/rsou/pro1/ex7.R", echo=TRUE)
# 원 그래프
df <- na.omit(stu)
df
pie(df$age)
pie(df$age, labels = df$age)
pie(df$age, labels = df$age, lty = 3)
# boxplot
boxplot(stu$height)
# boxplot
boxplot(stu$height, range = 0) # range = 1
ds <- read.csv("testdata/dataset.csv", header = T)
dim(ds) #300 7
head(ds, 2)
view(ds)
ds <- read.csv("testdata/dataset.csv", header = T)
dim(ds) #300 7
head(ds, 2)
view(ds)
View(ds)
# 극단치(outlier) : 비정상으로 분포를 벗어난 값
gender <- ds$gender
gender
table(gender)
hist(gender)
# gender 변수(열, 칼럼, 차원) 정제
data <- subset(ds, ds$gender == 1 | ds$gender == 2) # 성별이 1,2인 경우만 반환
length(data$gender)
install.packages("DBI")
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("RJDBC")
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
# 개인용 DB : Sqlite와 연동
install.packages("RSQLite")
library(RSQLite)
mtcars # 자동차 정보 dataset
dim(mtcars)
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
conn
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
conn
dbWriteTable(conn = conn, "mtcar", mtcars)
dbListTables(conn)
dbListFields(conn, "mtcar")
query <- "select * from mtcar"
resultAll <- dbGetQuery(conn, query)
resultAll
query <- "select mpg, cyl, carb, mpg+100 as good from mtcar where mpg >= 30"
resultPart <- dbGetQuery(conn, query)
resultPart
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath = "C:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("DBI")
install.packages("DBI")
install.packages("DBI")
install.packages("DBI")
install.packages("RJDBC")
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
# 개인용 DB : Sqlite와 연동
install.packages("RSQLite")
install.packages("RSQLite")
library(RSQLite)
mtcars # 자동차 정보 dataset
install.packages("RSQLite")
dim(mtcars)
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
conn
dbWriteTable(conn = conn, "mtcar", mtcars)
install.packages("RSQLite")
dbListFields(conn, "mtcar")
resultAll <- dbGetQuery(conn, query)
resultAll
query <- "select mpg, cyl, carb, mpg+100 as good from mtcar where mpg >= 30"
resultPart <- dbGetQuery(conn, query)
resultPart
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath = "C:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="C:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
