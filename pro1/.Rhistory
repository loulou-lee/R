dbListFields(conn, "mtcar")
query <- "select * from mtcar"
resultAll <- dbGetQuery(conn, query)
resultAll
query <- "select mpg, cyl, carb, mpg+100 as good from mtcar where mpg >= 30"
resultPart <- dbGetQuery(conn, query)
resultPart
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath = "C:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("DBI")
install.packages("DBI")
install.packages("DBI")
install.packages("DBI")
install.packages("RJDBC")
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
# 개인용 DB : Sqlite와 연동
install.packages("RSQLite")
install.packages("RSQLite")
library(RSQLite)
mtcars # 자동차 정보 dataset
install.packages("RSQLite")
dim(mtcars)
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
conn
dbWriteTable(conn = conn, "mtcar", mtcars)
install.packages("RSQLite")
dbListFields(conn, "mtcar")
resultAll <- dbGetQuery(conn, query)
resultAll
query <- "select mpg, cyl, carb, mpg+100 as good from mtcar where mpg >= 30"
resultPart <- dbGetQuery(conn, query)
resultPart
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath = "C:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="C:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("DBI")
install.packages("DBI")
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
install.packages("DBI")
library(RJDBC)
# 개인용 DB : Sqlite와 연동
install.packages("RSQLite")
install.packages("RSQLite")
mtcars # 자동차 정보 dataset
dim(mtcars)
install.packages("RSQLite")
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
conn
install.packages("RSQLite")
dbWriteTable(conn = conn, "mtcar", mtcars)
dbListTables(conn)
dbListFields(conn, "mtcar")
query <- "select * from mtcar"
resultAll <- dbGetQuery(conn, query)
resultAll
query <- "select mpg, cyl, carb, mpg+100 as good from mtcar where mpg >= 30"
resultPart <- dbGetQuery(conn, query)
resultPart
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("DBI")
install.packages("DBI")
install.packages("RJDBC")
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
install.packages("DBI")
library(DBI)
library(RJDBC)
# 개인용 DB : Sqlite와 연동
install.packages("RSQLite")
library(RSQLite)
mtcars # 자동차 정보 dataset
dim(mtcars)
conn <- dbConnect(RSQLite::SQLite(), ':memory:')
install.packages("DBI")
install.packages("DBI")
conn
dbWriteTable(conn = conn, "mtcar", mtcars)
dbListTables(conn)
dbListFields(conn, "mtcar")
query <- "select * from mtcar"
resultAll <- dbGetQuery(conn, query)
resultAll
query <- "select mpg, cyl, carb, mpg+100 as good from mtcar where mpg >= 30"
resultPart <- dbGetQuery(conn, query)
resultPart
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("DBI")
install.packages("DBI")
install.packages("DBI")
install.packages("RJDBC")
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
library(DBI)
library(RJDBC)
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test")
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test", "root","123")
conn
dbListTables(conn)
# sangdata table로 crud 경험
query <- "select * from sangdata"
goodsAll <- dbGetQuery(conn, query)
goodsAll
is(goodsAll)
head(goodsAll, 3)
mean(goodsAll$su)
hist(goodsAll$su)
barplot(goodsAll$su, col=rainbow(10), names.arg = goodsAll$sang)
goods <- dbGetQuery(conn, "select * from sangdata where sang like '가죽%'")
goods
query <- "select code as 코드, sang as 품명 from sangdata order by code desc"
dbGetQuery(conn, query)
df <- dbGetQuery(conn, query)
str(df)
# 레코드 추가
iquery <- "insert into sangdata values(8,'핸드크림',34,5000)"
dbSendUpdate(conn, iquery)
df <- data.frame(code=9, sang='립밤', su=12, dan=2000)
df
df <- data.frame(code=9, sang='립밤', su=12, dan=2000)
df
dbSendUpdate(conn, "insert into sangdata values(?,?,?,?)", df$code, df$sang, df$su, df$dan)
dbGetQuery(conn, "select * from sangdata")
# 레코드 수정
uquery <- "update sangdata set sang='꽃' where code=9"
dbGetQuery(conn, "select * from sangdata")
sangdf <- read.csv("sangpum.csv", header = T, fileEncoding = "utf-8")
sangdf <- read.csv("sangpum.csv", header = T, fileEncoding = "utf-8")
sangdf
sangdf <- read.csv("sangpum.csv", header = T, fileEncoding = "utf-8")
sangdf
# push data
func(conn, "sangdata", sangdf)
# 여러 개의 행을 가진 data.frame의 자료를 DB에 추가하려면 함수 작성
func <- function(conn, table, df){
batch <- apply(df, 1, FUN = function(x) paste0("'", trimws(x), "'"), collapse=",") %>%
paste0("(",.,")", collapse = ",\n")
print(batch)
}
# push data
func(conn, "sangdata", sangdf)
batch <- apply(df, 1, FUN = function(x) paste0("'", trimws(x), "'", collapse=",")) %>%
paste0("(",.,")", collapse = ",\n")
print(batch)
install.packages("dplyr")
library(dplyr) # %>% 연산자를 사용하기 위함
# 여러 개의 행을 가진 data.frame의 자료를 DB에 추가하려면 함수 작성
func <- function(conn, table, df){
batch <- apply(df, 1, FUN = function(x) paste0("'", trimws(x), "'", collapse=",")) %>%
paste0("(",.,")", collapse = ",\n")
print(batch)
}
# push data
func(conn, "sangdata", sangdf)
#print(batch)
iquery <- paste("insert into", table, "values", batch)
dbSendUpdate(conn, iquery)
# 여러 개의 행을 가진 data.frame의 자료를 DB에 추가하려면 함수 작성
func <- function(conn, table, df){
batch <- apply(df, 1, FUN = function(x) paste0("'", trimws(x), "'", collapse=",")) %>%
paste0("(",.,")", collapse = ",\n")
#print(batch)
iquery <- paste("insert into", table, "values", batch)
dbSendUpdate(conn, iquery)
}
# push data
func(conn, "sangdata", sangdf)
dbGetQuery(conn, "select * from sangdata")
dbDisconnect(conn)
stu <- read.csv("testdata/ex_studentlist.csv", fileEncoding = "utf-8")
head(stu, 3)
str(stu)
names(stu)
# 막대
barplot(stu$grade)
barplot(stu$grade, ylim = c(0, 5), col = rainbow(3), main = '세로막대')
barplot(stu$grade, ylim = c(0, 5), col = rainbow(3),
xlab = '학년',ylab = '학생', main = '가로막대', horiz = T)
barplot(stu$grade, col = c(1,2,3,4,5))
par(mfrow=c(1,2))
# par(mfcol=c(1,2))
barplot(stu$grade,col = c(1,2,3))
barplot(stu$grade,col = c(1,2,3), horiz = T)
qplot
par(mfrow=c(1,1))
barplot(stu$grade,col = c(1,2,3), space = 2) #막대와 막대 사이 간격 space
# 점 차트
dotchart(stu$grade)
dotchart(stu$grade, color = 2:5, lcolor = 'black', pch = 1:3, cex = 1.5)
# 원 그래프
df <- na.omit(stu)
df
pie(df$age, labels = df$age, lty = 3)
# boxplot
min(stu$height)
max(stu$height)
boxplot(stu$height, range = 0) # range = 1
boxplot(stu$height, range = 1, notch = T)
# 회귀식 적합도에 대한 가설 검정
# iris dataset
head(iris, 3)
cor(iris[, -5])
cor(iris$Sepal.Length, iris$Sepal.Width) # -0.1175698
plot(iris$Sepal.Length, iris$Sepal.Width) # 산포도(시각화)
# Sepal.Length가 Sepal.Width에 영향을 주는가?
# 선형회귀분석 , ML 지도학습 지금까지
model1 <- lm(formula = Sepal.width ~ Sepal.Length, data = iris)
# 회귀식 적합도에 대한 가설 검정
# iris dataset
head(iris, 3)
cor(iris[, -5]) # 상관관계 나옴
cor(iris$Sepal.Length, iris$Sepal.Width) # -0.1175698 , 음의 상관관계가 약함 우하향
plot(iris$Sepal.Length, iris$Sepal.Width) # 산포도(시각화)
# Sepal.Length가 Sepal.Width에 영향을 주는가?
# 선형회귀분석 , ML 지도학습 지금까지
model1 <- lm(formula = Sepal.width ~ Sepal.Length, data = iris)
model1
# Sepal.Length가 Sepal.Width에 영향을 주는가?
# 선형회귀분석 , ML 지도학습 지금까지
model1 <- lm(formula = Sepal.Width ~ Sepal.Length, data = iris)
model1
summary(model1)
# 평가 : Sepal.Length가 Sepal.Width에 영향을 주지 않는다.
0.1175698 ** 2 # 상관계수 제곱하면 R-squared:  0.01382
cor(iris$Sepal.Length, iris$Petal.Length)
plot(iris$Sepal.Length, iris$Petal.Length) # 산포도(시각화)
cor(iris$Sepal.Length, iris$Petal.Length)
plot(iris$Sepal.Length, iris$Petal.Length) # 산포도(시각화)
# Sepal.Length가 Petal.Length에 영향을 주는가?
# 선형회귀분석2
model2 <- lm(formula = Petal.Length ~ Sepal.Length, data = iris)
summary(model2) # 모델의 p-value: 0.1519 > 0.05이므로 의미없는 모델
# 평가 : Sepal.Length가 Petal.Length에 영향을 준다.
# R-squared: 0.76, 76%설명한다 정확하다고 하면 안되는데 분류에서 정확하다고 표현한다
0.2 ** 2
# 평가 : Sepal.Length가 Petal.Length에 영향을 준다.
# R-squared: 0.76, 76%설명한다 정확하다고 하면 안되는데 분류에서 정확하다고 표현한다
0.8 ** 2
# 회귀모델 평가
cars # 자동차의 속도와 제동거리
cor(cars) # 상관계수 확인
model <- lm(formula = dist ~ speed, data = cars)
summary(model)
fitted(model)[1:4]
coef(model) # 회귀계수
fitted(model)[1:4]
fitted(model)[1:4] # 모델이 예측한 값(dist)
residuals(model)[1:4] # 잔차
residuals(model)[1:4] # 모델과 실제값과의 차이(residuals, 잔차)
cars[1:4,]
cars[1:4,]
fitted(model)[1:4] + residuals(model)[1:4] # 예측값 + 잔차 = 실제값, 잔차 = 실제값 - 예측값
# 모델 간 평가
full_model <- lm(dist ~ speed, data = cars)
full_model
# 모델 간 평가
full_model <- lm(dist ~ speed, data = cars) # 완전모형
full_model
reduce_model <- lm(dist ~ 1, data = cars) # 축소모형
reduce_model
anova(reduce_model, full_model) # 두 모델을 비교
# 회귀모델 평가
cars # 자동차의 속도와 제동거리
# 정형 데이터(필드가 있다) 처리 : RDBMS와 연동
# RJDBC api를 사용
install.packages("rJava")
install.packages("rJava")
install.packages("DBI")
install.packages("RJDBC")
# Sys.setenv(JAVA_HOME="c:/Program Files/Java/jdk-11.0.5")
library(rJava)
library(DBI)
library(RJDBC)
# 개인용 DB : Sqlite와 연동
install.packages("RSQLite")
library(RSQLite)
# 원격 DB : MariaDb와 연동
drv <- JDBC(driverClass = "org.mariadb.jdbc.Driver",
classPath ="c:/work/mariadb-java-client-2.6.2.jar") #이 파일 안에 driver이 있다.
conn <- dbConnect(drv = drv, "jdbc:mysql://127.0.0.1:3306/test", "root","123")
conn
dbListTables(conn)
# sangdata table로 crud 경험
query <- "select * from jikwon"
goodsAll <- dbGetQuery(conn, query)
goodsAll
is(goodsAll)
goods <- dbGetQuery(conn, "select jikwon_pay as 연봉, date_format(now(),'%Y'), date_format(jikwon_ibsail,'%Y') from jikwon")
goods
goods <- dbGetQuery(conn, "select jikwon_pay as 연봉, date_format(now(),'%Y') - date_format(jikwon_ibsail,'%Y') from jikwon")
goods
goods <- dbGetQuery(conn, "select jikwon_pay as 연봉, date_format(now(),'%Y') - date_format(jikwon_ibsail,'%Y') from jikwon as 근무년수")
goods
goods <- dbGetQuery(conn, "select jikwon_pay as 연봉, date_format(now(),'%Y') - date_format(jikwon_ibsail,'%Y') as 근무년수 from jikwon")
goods
employee <- dbGetQuery(conn, "select jikwon_pay as 연봉, date_format(now(),'%Y') - date_format(jikwon_ibsail,'%Y') as 근무년수 from jikwon")
employee
#-----------------------------
cor(employee) #상관계수 확인
# 회귀모델 평가
cars # 자동차의 속도와 제동거리
cor(cars) # 상관계수 확인
model <- lm(formula = 연봉 ~ 근무년수, data = employee)
summary(model)
summary(model) # 0.6511 65.1%의 설명력을 가진다.
model <- lm(formula = dist ~ speed, data = cars)
summary(model) # 0.6511 65.1%의 설명력을 가진다.
#근무년수 입력받기
y_num <- readline('근무년수 입력:')
y_num <- as.numeric(y_num)
predict(model, newdata = data.frame(y_num)
predict(model, newdata = data.frame(y_num))
coef(model) # 회귀계수
fitted(model)[1:4] # 모델이 예측한 값(dist)
#fitted(model)
pre <- predict(model, newdata = data.frame(근무년수=y_num))
#fitted(model)
testData <- data.frame(근무년수=y_num)
pre <- predict(model, testData)
head(pre)
query <- "select * from jikwon"
goodsAll <- dbGetQuery(conn, query)
goodsAll
is(goodsAll)
employee <- dbGetQuery(conn, "select jikwon_pay as 연봉, date_format(now(),'%Y') - date_format(jikwon_ibsail,'%Y') as 근무년수 from jikwon")
employee
#-----------------------------
cor(employee) # 상관계수 확인 0.9196725 양의 상관관계가 강함 우상향
model <- lm(formula = 연봉 ~ 근무년수, data = employee)
summary(model) # p-value: 6.943e-13 < 0.05 이므로 현재 모델은 유의하다 84.5%의 설명력을 가진다
#근무년수 입력받기
y_num <- readline('근무년수 입력:')
y_num <- as.numeric(y_num)
#fitted(model)
testData <- data.frame(근무년수=y_num)
pre <- predict(model, testData)
head(pre)
testData
plot(연봉~근무년수, data = employee)
abline(lm(연봉 ~ 근무년수, data=emp),col="669933",lwd=2)
abline(lm(연봉 ~ 근무년수, data=employee),col="669933",lwd=2)
#근무년수 입력받기
y_num <- readline('근무년수 입력:')
y_num <- as.numeric(y_num)
testData <- data.frame(근무년수=y_num)
testData
#predict(model1, newdata = data.frame(근무년수=y_num))
pre <- predict(model, testData) #model : 예측에 사용할 회귀분석 결과식
#newdata : 예측에 사용할 x값, 값을 지정하지 않을시 1~45 정수값에 대한 예측값을 출력한다.
#newdata에 사용할 x값을 지정할 때에는 주의 해야한다. data.frame의 colname을 회귀분석에서 사용한 설명변수 명과 동일하게 설정해야지 predict() command 사용시 오류가 발생하지 않는다.
head(pre)
head(state.x77, 3)
colnames(state.x77)
dim(state.x77)
mfit
head(state.x77, 3)
colnames(state.x77)
dim(state.x77) # 50 by 8
str(state.x77) # 구조
cor(state.x77)
states <- as.data.frame(state.x77[,c('Murder',' Population','Illiteracy','Income','Frost')])
head(states,3)
cor(states)
# 다중회귀모델
mfit <- lm(formula = Murder ~ Population+Illiteracy+Income+Frost, data=states) #독립변수를 + 로 묶을 수 있다
mfit
states <- as.data.frame(state.x77[,c('Murder',' Population','Illiteracy','Income','Frost')])
head(state.x77, 3)
colnames(state.x77)
dim(state.x77) # 50 by 8
str(state.x77) # 구조
cor(state.x77)
states <- as.data.frame(state.x77[,c('Murder',' Population','Illiteracy','Income','Frost')])
head(states,3)
states <- as.data.frame(state.x77[,c('Murder',' Population','Illiteracy','Income','Frost')])
states <- as.data.frame(state.x77[,c('Murder', 'Population', 'Illiteracy', 'Income', 'Frost')])
head(states,3)
cor(states)
# 다중회귀모델
mfit <- lm(formula = Murder ~ Population+Illiteracy+Income+Frost, data=states) #독립변수를 + 로 묶을 수 있다
mfit
# 모델을 시각화
par(mfrow=c(2, 2))
plot(mfit)
plot(mfit)
# 잔차항의 정규성 검정
shapiro.test(residuals(mfit))
# 독립성 검정 , 자기상관이 없어야 독립적이다 더빈-와트슨
install.packages("car")
library(car)
# 선형성 검정
boxTidwell(Murder ~ Population+Illiteracy, data = states)
# 등분산성 검정
ncvTest(mfit)
# 다중공선성 검정
vif(mfit)
# AIC 통계량 : 모델의 상대적 품질을 평가하는 척도. 효과적인 독립변수를 선택할 수 있다.
model1 <- lm(formula = Murder ~ ., data = states)
summary(model1)
# AIC 통계량으로 두 모델의 성능 비교
AIC(model1, model2)
model2 <- lm(formula = Murder ~ Population + Illiteracy, data = states)
summary(model2)
# AIC 통계량으로 두 모델의 성능 비교
AIC(model1, model2)
reduce_model <- step(full_model, direction = 'backward')
# AIC 통계량 : 모델의 상대적 품질을 평가하는 척도. 효과적인 독립변수를 선택할 수 있다.
model1 <- lm(formula = Murder ~ ., data = states)
summary(model1)
model2 <- lm(formula = Murder ~ Population + Illiteracy, data = states)
summary(model2)
# AIC 통계량으로 두 모델의 성능 비교
AIC(model1, model2)
# stepwise regression : 단계적으로 모형을 검정하면서 AIC 값을 비교한 후 가장 적합한 회귀모형을 찾아준다.
# backward(후진소거법) : 모든 변수를 독립변수로 주고, 기여도가 낮은 것 부터 하나씩 제거
full_model <- lm(Murder ~ ., data=states)
reduce_model <- step(full_model, direction = 'backward')
summary(reduce_model)
# stepwise regression : 단계적으로 모형을 검정하면서 AIC 값을 비교한 후 가장 적합한 회귀모형을 찾아준다.
# backward(후진소거법) : 모든 변수를 독립변수로 주고, 기여도가 낮은 것 부터 하나씩 제거
full_model <- lm(Murder ~ ., data=states) # AIC가 낮을수록 좋다
reduce_model <- step(full_model, direction = 'backward')
summary(reduce_model)
# forward(전진선택법) : 유익한 변수부터 하나씩 독립변수로 추가
min_model <- lm(Murder ~ 1, data=states)
fwd_model <- step(min_model, direction = 'forward',
scope=(Murder ~ Population+Illiteracy+Income+Frost), trace=1)
summary(fwd_model)
one_model <- lm(Murder ~ Population, data=states)
summary(one_model)
# AIC 통계량으로 두 모델의 성능 비교
AIC(model1, model2)
# 단순/다중 선형회귀 모델 작성 후 정량적인 예측 결과 받아보기
head(mtcars)
# 연습1 - 단순선형회귀
# 임의의 마력수를 입력하면 연비를 예측하는 모델
# 변수는 mpg(연비), hp(마력수)
cor(mtcars$hp, mtcars$mpg)
plot(mpg ~ hp, data = mtcars, xlab='마력수', ylab='연비')
# 단순/다중 선형회귀 모델 작성 후 정량적인 예측 결과 받아보기
head(mtcars)
# 연습1 - 단순선형회귀
# 임의의 마력수를 입력하면 연비를 예측하는 모델
# 변수는 mpg(연비), hp(마력수)
cor(mtcars$hp, mtcars$mpg) #  -0.7761684
par(mar=c(1,1,1,1))
plot(mpg ~ hp, data = mtcars, xlab='마력수', ylab='연비')
# 인과관계가 있다고 판단함
model1 <- lm(formula = mpg ~ hp, data = mtcars)
model1
# 미지의 hp(마력수)에 대한 mpg(연비) 예측 : 수식 사용
new_hp <- 110
mynew <- edit(mynew)
# 미지의 hp(마력수)에 대한 mpg(연비) 예측 : 함수 사용
# 미지의 값을 직접 작성할 수 있으나 기존값을 수정하는 방법
mynew <- mtcars[c(1,2),]
mynew <- edit(mynew)
mynew
pred <- predict(model1, newdata = mynew)
pred
cat('예측값 : ', pred)
# 연습2 - 다중선형회귀
# 임의의 마력수와 차체무게를 입력하면 연비를 예측하는 모델
# 변수는 mpg(연비), wt(차체무게),  hp(마력수)
cor(mtcars$hp, mtcars$mpg) # -0.7761684
cor(mtcars$wt, mtcars$mpg)
model2 <- lm(formula = mpg ~ hp + wt, data = mtcars)
model2
model2 <- lm(formula = mpg ~ hp + wt, data = mtcars)
model2
# y_hat = -0.03177 * hp + -3.87783 * wt + 37.22727
summary(model2)
# 예측값 / 실제값 비교
pred2 <- predict(model2)
cat('예측값 : ', pred2[1:10])
cat('실제값 : ', mtcars$mpg[1:10])
